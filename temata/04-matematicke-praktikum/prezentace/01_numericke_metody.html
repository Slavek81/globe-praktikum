<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numerick√© metody pro hled√°n√≠ ko≈ôen≈Ø funkc√≠ - Matematick√© praktikum</title>
    <!-- Import pro renderov√°n√≠ LaTeX matematick√Ωch vzorc≈Ø -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <link rel="stylesheet" href="unified-style.css">
</head>
<body>
    <main>
        <header>
            <h1>Numerick√© metody pro hled√°n√≠ ko≈ôen≈Ø funkc√≠</h1>
            <p>Kompletn√≠ pr≈Øvodce modern√≠mi metodami pro ≈ôe≈°en√≠ neline√°rn√≠ch rovnic</p>
        </header>

        <section class="intro-box">
            <h2>Co jsou numerick√© metody a proƒç jsou d≈Øle≈æit√©?</h2>
            <p>P≈ôedstavte si, ≈æe pot≈ôebujete naj√≠t ≈ôe≈°en√≠ rovnice jako \(x^3 - 6x^2 + 9x + 1 = 0\). Analytick√© ≈ôe≈°en√≠ takov√Ωch rovnic je ƒçasto nemo≈æn√© nebo velmi slo≈æit√©. Proto pou≈æ√≠v√°me <strong>numerick√© metody</strong> - algoritmy, kter√© n√°m pomohou naj√≠t p≈ôibli≈æn√© ≈ôe≈°en√≠ s libovolnou p≈ôesnost√≠.</p>

            <div style="background: linear-gradient(135deg, #003f5c, #58508d); color: white; padding: 2rem; border-radius: 16px; margin: 2rem 0; text-align: center;">
                <h3 style="color: white; margin-bottom: 1rem;">Ko≈ôen funkce f(x)</h3>
                <p style="font-size: 1.2rem; margin-bottom: 0;">je hodnota x*, pro kterou plat√≠ <strong>f(x*) = 0</strong></p>
            </div>

            <h3>Proƒç pot≈ôebujeme numerick√© metody?</h3>
            <ul>
                <li><strong>Analytick√© ≈ôe≈°en√≠ neexistuje:</strong> Mnoh√© rovnice nemaj√≠ uzav≈ôen√© algebraick√© ≈ôe≈°en√≠</li>
                <li><strong>Slo≈æitost funkc√≠:</strong> Komplexn√≠ funkce jsou obt√≠≈ænƒõ ≈ôe≈°iteln√© klasick√Ωmi metodami</li>
                <li><strong>Rychlost:</strong> Poƒç√≠taƒçe dok√°≈æ√≠ velmi rychle prov√°dƒõt iterativn√≠ v√Ωpoƒçty</li>
                <li><strong>Kontrolovan√° p≈ôesnost:</strong> M≈Ø≈æeme si zvolit, jak p≈ôesn√© ≈ôe≈°en√≠ pot≈ôebujeme</li>
            </ul>
        </section>

        <!-- Newton-Raphson Method -->
        <section class="unit-section">
            <h2>1. Newton-Raphsonova metoda</h2>
            <p><strong>Princip:</strong> Nejrychlej≈°√≠ a nejpou≈æ√≠vanƒõj≈°√≠ metoda zalo≈æen√° na linearizaci funkce pomoc√≠ teƒçny. Je to geometrick√° interpretace Taylorova rozvoje prvn√≠ho ≈ô√°du.</p>

            <div class="equations">
                <h3>Iteraƒçn√≠ vzorec</h3>
                <p><strong>Z√°kladn√≠ vzorec:</strong> Pokud m√°me funkci f(x) a jej√≠ derivaci f'(x), nov√° aproximace se poƒç√≠t√° jako:
                $$ x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)} $$</p>

                <h4>Algoritmus:</h4>
                <ol>
                    <li>Zvol√≠me poƒç√°teƒçn√≠ odhad x‚ÇÄ</li>
                    <li>Sestroj√≠me teƒçnu v bodƒõ [x‚ÇÄ, f(x‚ÇÄ)]</li>
                    <li>Najdeme pr≈Øseƒç√≠k teƒçny s osou x ‚Üí x‚ÇÅ</li>
                    <li>Opakujeme dokud |x_{k+1} - x_k| < Œµ</li>
                </ol>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div class="advantages">
                    <h4>‚úÖ V√Ωhody:</h4>
                    <ul>
                        <li><strong>Kvadratick√° konvergence:</strong> Poƒçet spr√°vn√Ωch cifer se p≈ôi ka≈æd√© iteraci zdvojn√°sob√≠</li>
                        <li><strong>Rychlost:</strong> Velmi efektivn√≠ pro hladk√© funkce</li>
                        <li><strong>≈†irok√© pou≈æit√≠:</strong> Funguje pro vƒõt≈°inu praktick√Ωch probl√©m≈Ø</li>
                    </ul>
                </div>
                <div class="disadvantages">
                    <h4>‚ùå Nev√Ωhody:</h4>
                    <ul>
                        <li><strong>Vy≈æaduje derivaci:</strong> Mus√≠me zn√°t nebo spoƒç√≠tat f'(x)</li>
                        <li><strong>M≈Ø≈æe divergovat:</strong> P≈ôi f'(x) ‚âà 0 nebo ≈°patn√©m poƒç√°teƒçn√≠m odhadu</li>
                        <li><strong>Lok√°ln√≠ metoda:</strong> Najde nejbli≈æ≈°√≠ ko≈ôen, ne nutnƒõ ten po≈æadovan√Ω</li>
                    </ul>
                </div>
            </div>

            <div class="example">
                <h3>Vizualizace metody</h3>
                <div style="background: white; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">
                    <div id="newton-graph" style="height: 400px;"></div>
                </div>
            </div>
        </section>

        <!-- Bisection Method -->
        <section class="unit-section">
            <h2>2. Metoda p≈Ølen√≠ intervalu (Bisekce)</h2>
            <p><strong>Princip:</strong> Nejspolehlivƒõj≈°√≠ metoda zalo≈æen√° na Bolzanovƒõ vƒõtƒõ o spojit√Ωch funkc√≠ch. Garantuje nalezen√≠ ko≈ôene, pokud existuje v dan√©m intervalu.</p>

            <div class="equations">
                <h3>Teoretick√Ω z√°klad - Bolzanova vƒõta</h3>
                <p><strong>Vƒõta:</strong> Pokud je funkce f(x) spojit√° na intervalu [a,b] a plat√≠ f(a)¬∑f(b) < 0, pak existuje alespo≈à jedno c ‚àà (a,b) takov√©, ≈æe f(c) = 0.</p>

                <h4>Algoritmus:</h4>
                <ol>
                    <li>Najdeme interval [a,b] kde f(a)¬∑f(b) < 0</li>
                    <li>Vypoƒçteme st≈ôed c = (a + b) / 2</li>
                    <li>Zkontrolujeme f(c):
                        <ul>
                            <li>Pokud f(a)¬∑f(c) < 0 ‚Üí b = c (ko≈ôen je v lev√© polovinƒõ)</li>
                            <li>Pokud f(b)¬∑f(c) < 0 ‚Üí a = c (ko≈ôen je v prav√© polovinƒõ)</li>
                        </ul>
                    </li>
                    <li>Opakujeme dokud |b - a| < Œµ</li>
                </ol>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div class="advantages">
                    <h4>‚úÖ V√Ωhody:</h4>
                    <ul>
                        <li><strong>Zaruƒçen√° konvergence:</strong> V≈ædy najde ko≈ôen (pokud existuje)</li>
                        <li><strong>Velmi robustn√≠:</strong> Funguje i pro "≈°patn√©" funkce</li>
                        <li><strong>Nevy≈æaduje derivaci:</strong> Staƒç√≠ pouze funkƒçn√≠ hodnoty</li>
                        <li><strong>P≈ôedv√≠dateln√° rychlost:</strong> Ka≈æd√° iterace zmen≈°√≠ interval na polovinu</li>
                    </ul>
                </div>
                <div class="disadvantages">
                    <h4>‚ùå Nev√Ωhody:</h4>
                    <ul>
                        <li><strong>Pomal√° konvergence:</strong> Line√°rn√≠ rychlost konvergence</li>
                        <li><strong>Pot≈ôebuje poƒç√°teƒçn√≠ interval:</strong> Mus√≠me naj√≠t [a,b] se zmƒõnou znam√©nka</li>
                        <li><strong>Jen pro spojit√© funkce:</strong> Nefunguje u funkc√≠ s nespojitostmi</li>
                    </ul>
                </div>
            </div>

            <div class="example">
                <h3>Vizualizace metody</h3>
                <div style="background: white; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">
                    <div id="bisection-graph" style="height: 400px;"></div>
                </div>
            </div>
        </section>

        <!-- Secant Method -->
        <section class="unit-section">
            <h2>3. Metoda seƒçen</h2>
            <p><strong>Princip:</strong> Podob√° se Newton-Raphsonovƒõ metodƒõ, ale derivaci nahrazuje <strong>rozd√≠lov√Ωm pod√≠lem</strong>. Je to kompromis mezi rychlost√≠ a praktiƒçnost√≠.</p>

            <div class="equations">
                <h3>Iteraƒçn√≠ vzorec</h3>
                <p><strong>Z√°kladn√≠ vzorec:</strong> Derivaci f'(x_k) nahrad√≠me rozd√≠lov√Ωm pod√≠lem:
                $$ x_{k+1} = x_k - f(x_k) \cdot \frac{x_k - x_{k-1}}{f(x_k) - f(x_{k-1})} $$</p>

                <h4>Algoritmus:</h4>
                <ol>
                    <li>Zvol√≠me dva poƒç√°teƒçn√≠ odhady x‚ÇÄ a x‚ÇÅ</li>
                    <li>Sestroj√≠me seƒçnu body [x‚ÇÄ, f(x‚ÇÄ)] a [x‚ÇÅ, f(x‚ÇÅ)]</li>
                    <li>Najdeme pr≈Øseƒç√≠k seƒçny s osou x ‚Üí x‚ÇÇ</li>
                    <li>Posuneme se: x‚ÇÄ ‚Üê x‚ÇÅ, x‚ÇÅ ‚Üê x‚ÇÇ</li>
                    <li>Opakujeme proces</li>
                </ol>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div class="advantages">
                    <h4>‚úÖ V√Ωhody:</h4>
                    <ul>
                        <li><strong>Nepot≈ôebuje derivaci:</strong> Pou≈æ√≠v√° pouze funkƒçn√≠ hodnoty</li>
                        <li><strong>Superline√°rn√≠ konvergence:</strong> Rychlost p ‚âà 1.618 (zlat√Ω ≈ôez!)</li>
                        <li><strong>Rychlej≈°√≠ ne≈æ bisekce:</strong> Mnohem efektivnƒõj≈°√≠ ne≈æ line√°rn√≠ metody</li>
                    </ul>
                </div>
                <div class="disadvantages">
                    <h4>‚ùå Nev√Ωhody:</h4>
                    <ul>
                        <li><strong>M≈Ø≈æe divergovat:</strong> Nen√≠ zaruƒçen√° konvergence</li>
                        <li><strong>Pot≈ôebuje dva poƒç√°teƒçn√≠ body:</strong> Slo≈æitƒõj≈°√≠ inicializace</li>
                        <li><strong>Citliv√° na volbu bod≈Ø:</strong> ≈†patn√© poƒç√°teƒçn√≠ body mohou zp≈Øsobit probl√©my</li>
                    </ul>
                </div>
            </div>

            <div class="example">
                <h3>Vizualizace metody</h3>
                <div style="background: white; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">
                    <div id="secant-graph" style="height: 400px;"></div>
                </div>
            </div>
        </section>

        <!-- Fixed Point Iteration -->
        <section class="unit-section">
            <h2>4. Prost√° iterace (Fixed-point iteration)</h2>
            <p><strong>Princip:</strong> P≈ôevedeme rovnici f(x) = 0 na tvar x = g(x) a hled√°me pevn√Ω bod funkce g(x). Nejjednodu≈°≈°√≠ metoda na implementaci.</p>

            <div class="equations">
                <h3>Teoretick√Ω z√°klad</h3>
                <p><strong>P≈ôevod rovnice:</strong> f(x) = 0 ‚Üí x = g(x)</p>
                <p><strong>Iteraƒçn√≠ vzorec:</strong> $$ x_{k+1} = g(x_k) $$</p>

                <h4>Podm√≠nka konvergence</h4>
                <p><strong>Banachova vƒõta o kontrakci:</strong> Pokud |g'(x)| < 1 v okol√≠ pevn√©ho bodu, pak iterace konverguje k tomuto bodu.</p>

                <h4>Pavuƒçinov√Ω diagram</h4>
                <p>Grafick√° interpretace: Iterace st≈ô√≠davƒõ "sk√°ƒçou" mezi k≈ôivkou y = g(x) a p≈ô√≠mkou y = x.</p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div class="advantages">
                    <h4>‚úÖ V√Ωhody:</h4>
                    <ul>
                        <li><strong>Velmi jednoduch√° implementace:</strong> Pouze jeden vzorec</li>
                        <li><strong>Nevy≈æaduje derivaci ani interval:</strong> Staƒç√≠ jedna poƒç√°teƒçn√≠ hodnota</li>
                        <li><strong>Univers√°ln√≠:</strong> Funguje pro r≈Øzn√© typy rovnic</li>
                    </ul>
                </div>
                <div class="disadvantages">
                    <h4>‚ùå Nev√Ωhody:</h4>
                    <ul>
                        <li><strong>M≈Ø≈æe snadno divergovat:</strong> Z√°vis√≠ na volbƒõ funkce g(x)</li>
                        <li><strong>Nutn√° vhodn√° transformace:</strong> Nen√≠ v≈ædy jasn√©, jak p≈ôev√©st f(x) = 0 na x = g(x)</li>
                        <li><strong>Pomal√° konvergence:</strong> Obvykle jen line√°rn√≠ rychlost</li>
                    </ul>
                </div>
            </div>

            <div class="example">
                <h3>Vizualizace metody - Pavuƒçinov√Ω diagram</h3>
                <div style="background: white; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">
                    <div id="fixed-point-graph" style="height: 400px;"></div>
                </div>
            </div>
        </section>

        <!-- Regula Falsi -->
        <section class="unit-section">
            <h2>5. Regula falsi (Fale≈°n√° poloha)</h2>
            <p><strong>Princip:</strong> Kombinuje rychlost metody seƒçen se spolehlivost√≠ bisekce. Vyu≈æ√≠v√° line√°rn√≠ interpolaci, ale zachov√°v√° interval se zmƒõnou znam√©nka.</p>

            <div class="equations">
                <h3>Iteraƒçn√≠ vzorec</h3>
                <p><strong>Line√°rn√≠ interpolace:</strong> Pr≈Øseƒç√≠k p≈ô√≠mky proch√°zej√≠c√≠ body [a, f(a)] a [b, f(b)] s osou x:
                $$ c = \frac{a \cdot f(b) - b \cdot f(a)}{f(b) - f(a)} $$</p>

                <h4>Algoritmus:</h4>
                <ol>
                    <li>Najdeme interval [a,b] kde f(a)¬∑f(b) < 0</li>
                    <li>Provedeme line√°rn√≠ interpolaci ‚Üí pr≈Øseƒç√≠k c</li>
                    <li>Zachov√°me interval se zmƒõnou znam√©nka:
                        <ul>
                            <li>Pokud f(a)¬∑f(c) < 0 ‚Üí b = c</li>
                            <li>Pokud f(b)¬∑f(c) < 0 ‚Üí a = c</li>
                        </ul>
                    </li>
                    <li>Iterujeme s nov√Ωm intervalem</li>
                </ol>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div class="advantages">
                    <h4>‚úÖ V√Ωhody:</h4>
                    <ul>
                        <li><strong>Garantovan√° konvergence:</strong> Jako bisekce, ale rychlej≈°√≠</li>
                        <li><strong>Rychlej≈°√≠ ne≈æ bisekce:</strong> Vyu≈æ√≠v√° sklony funkce</li>
                        <li><strong>Nepot≈ôebuje derivaci:</strong> Jen funkƒçn√≠ hodnoty</li>
                        <li><strong>Robustn√≠:</strong> Funguje i pro slo≈æit√© funkce</li>
                    </ul>
                </div>
                <div class="disadvantages">
                    <h4>‚ùå Nev√Ωhody:</h4>
                    <ul>
                        <li><strong>M≈Ø≈æe "p≈ôilnout" k jednomu kraji:</strong> Jeden koncov√Ω bod se nemƒõn√≠</li>
                        <li><strong>Pomalej≈°√≠ ne≈æ Newton-Raphson:</strong> Jen superline√°rn√≠ konvergence</li>
                        <li><strong>Slo≈æitƒõj≈°√≠ ne≈æ bisekce:</strong> V√≠ce v√Ωpoƒçt≈Ø na iteraci</li>
                    </ul>
                </div>
            </div>

            <div class="example">
                <h3>Vizualizace metody</h3>
                <div style="background: white; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">
                    <div id="regula-falsi-graph" style="height: 400px;"></div>
                </div>
            </div>
        </section>

        <!-- Optimization Section -->
        <section class="unit-section">
            <h2>6. Hled√°n√≠ extr√©m≈Ø funkc√≠ (Optimalizace)</h2>
            <p><strong>Princip:</strong> Mnoho technick√Ωch probl√©m≈Ø vy≈æaduje nalezen√≠ minima nebo maxima funkce - nap≈ô. minim√°ln√≠ n√°klady, maxim√°ln√≠ v√Ωkon, nebo optim√°ln√≠ rozmƒõry konstrukce.</p>

            <div class="intro-box">
                <h3>Praktick√© aplikace optimalizace</h3>
                <ul>
                    <li><strong>Minim√°ln√≠ tlou≈°≈•ka izolace:</strong> Optimalizace mezi √∫sporou energie a n√°klady na materi√°l</li>
                    <li><strong>Maxim√°ln√≠ zisk procesu:</strong> Nalezen√≠ optim√°ln√≠ch provozn√≠ch podm√≠nek</li>
                    <li><strong>Optim√°ln√≠ rozmƒõry n√°doby:</strong> Minimalizace spot≈ôeby materi√°lu p≈ôi dan√©m objemu</li>
                    <li><strong>Energetick√° √∫ƒçinnost:</strong> Maximalizace v√Ωkonu p≈ôi minim√°ln√≠ spot≈ôebƒõ</li>
                </ul>
            </div>

            <div class="equations">
                <h3>Z√°kladn√≠ teorie</h3>
                <p><strong>Nutn√° podm√≠nka pro extremum:</strong> V bodƒõ extr√©mu mus√≠ b√Ωt prvn√≠ derivace rovna nule:</p>
                $$f'(x^*) = 0$$

                <p><strong>Postaƒçuj√≠c√≠ podm√≠nky:</strong></p>
                <ul>
                    <li><strong>Minimum:</strong> \(f''(x^*) > 0\)</li>
                    <li><strong>Maximum:</strong> \(f''(x^*) < 0\)</li>
                    <li><strong>Inflexn√≠ bod:</strong> \(f''(x^*) = 0\) (nen√≠ extremum)</li>
                </ul>
            </div>

            <h3>Numerick√© metody pro optimalizaci</h3>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div>
                    <h4>üîç Metoda zlat√©ho ≈ôezu</h4>
                    <p><strong>Pou≈æit√≠:</strong> Jednorozmƒõrn√° optimalizace bez derivac√≠</p>
                    <p><strong>Princip:</strong> Postupn√© zu≈æov√°n√≠ intervalu v pomƒõru zlat√©ho ≈ôezu (œÜ ‚âà 1.618)</p>
                    <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                        <strong>Algoritmus:</strong>
                        <ol style="margin: 0.5rem 0;">
                            <li>Rozdƒõl√≠me interval [a,b] v pomƒõru zlat√©ho ≈ôezu</li>
                            <li>Vyhodnot√≠me funkci ve dvou vnit≈ôn√≠ch bodech</li>
                            <li>Eliminujeme ƒç√°st intervalu s hor≈°√≠ hodnotou</li>
                            <li>Opakujeme a≈æ do po≈æadovan√© p≈ôesnosti</li>
                        </ol>
                    </div>
                </div>
                <div>
                    <h4>üìà Newton-Raphsonova metoda pro optimalizaci</h4>
                    <p><strong>Pou≈æit√≠:</strong> Rychl√© hled√°n√≠ extr√©m≈Ø kdy≈æ zn√°me derivace</p>
                    <p><strong>Princip:</strong> Hled√°me ko≈ôeny prvn√≠ derivace</p>
                    <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                        <strong>Vzorec:</strong>
                        $$x_{k+1} = x_k - \frac{f'(x_k)}{f''(x_k)}$$
                        <p style="margin: 0.5rem 0;"><strong>V√Ωhoda:</strong> Kvadratick√° konvergence</p>
                        <p style="margin: 0;"><strong>Nev√Ωhoda:</strong> Pot≈ôebuje druhou derivaci</p>
                    </div>
                </div>
            </div>

            <div class="example">
                <h3>Praktick√Ω p≈ô√≠klad: Optim√°ln√≠ tlou≈°≈•ka izolace</h3>
                <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">

                    <h4>Zad√°n√≠ probl√©mu:</h4>
                    <p>Urƒçete optim√°ln√≠ tlou≈°≈•ku izolace pro minimalizace celkov√Ωch n√°klad≈Ø = n√°klady na izolaci + n√°klady na ztr√°ty tepla.</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin: 1.5rem 0;">
                        <div>
                            <h5>N√°kladov√° funkce:</h5>
                            <div class="equations">
                                $$C(x) = k_1 \cdot x + \frac{k_2}{x + x_0}$$
                            </div>
                            <ul style="font-size: 0.9rem;">
                                <li>\(x\) = tlou≈°≈•ka izolace [m]</li>
                                <li>\(k_1\) = cena izolace [Kƒç/m]</li>
                                <li>\(k_2\) = n√°klady na ztr√°ty [Kƒç¬∑m]</li>
                                <li>\(x_0\) = p≈Øvodn√≠ izolace [m]</li>
                            </ul>
                        </div>
                        <div>
                            <h5>≈òe≈°en√≠ optimalizace:</h5>
                            <div class="equations">
                                $$C'(x) = k_1 - \frac{k_2}{(x + x_0)^2} = 0$$
                                $$x_{opt} = \sqrt{\frac{k_2}{k_1}} - x_0$$
                            </div>
                            <div style="background: #d4edda; padding: 0.8rem; border-radius: 6px; margin-top: 1rem;">
                                <strong>V√Ωsledek:</strong> Optim√°ln√≠ tlou≈°≈•ka z√°vis√≠ na pomƒõru n√°klad≈Ø na energii a materi√°l
                            </div>
                        </div>
                    </div>

                    <div id="insulation-optimization" style="height: 350px; margin-top: 1rem;"></div>
                </div>
            </div>

            <div class="example">
                <h3>Numerick√© ≈ôe≈°en√≠ pomoc√≠ iterativn√≠ch metod</h3>
                <div style="background: white; border-radius: 12px; padding: 1.5rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">

                    <h4>1. Metoda zlat√©ho ≈ôezu</h4>
                    <p><strong>Princip:</strong> Postupnƒõ zu≈æujeme interval s minimem bez pou≈æit√≠ derivac√≠.</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin: 1rem 0;">
                        <div>
                            <h5>Algoritmus:</h5>
                            <ol style="font-size: 0.9rem;">
                                <li>Zvol√≠me poƒç√°teƒçn√≠ interval [a, b] = [0.001, 0.4]</li>
                                <li>Rozdƒõl√≠me interval v pomƒõru zlat√©ho ≈ôezu: œÜ = 1.618</li>
                                <li>Vypoƒçteme body: x‚ÇÅ = a + (b-a)/œÜ¬≤, x‚ÇÇ = a + (b-a)/œÜ</li>
                                <li>Vyhodnot√≠me C(x‚ÇÅ) a C(x‚ÇÇ)</li>
                                <li>Eliminujeme hor≈°√≠ polovinu intervalu</li>
                                <li>Opakujeme do dosa≈æen√≠ p≈ôesnosti</li>
                            </ol>
                        </div>
                        <div>
                            <h5>Iterace pro n√°≈° p≈ô√≠klad:</h5>
                            <div id="golden-section-result" style="font-family: monospace; font-size: 0.8rem; background: #f8f9fa; padding: 0.8rem; border-radius: 6px;">
                                <button onclick="runGoldenSection()" style="padding: 0.5rem; background: #007bff; color: white; border: none; border-radius: 4px; margin-bottom: 0.5rem;">
                                    Spus≈• metodu zlat√©ho ≈ôezu
                                </button>
                                <div id="golden-iterations"></div>
                            </div>
                        </div>
                    </div>

                    <h4>2. Newton-Raphsonova metoda pro optimalizaci</h4>
                    <p><strong>Princip:</strong> Hled√°me ko≈ôen prvn√≠ derivace funkce C'(x) = 0.</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin: 1rem 0;">
                        <div>
                            <h5>Matematick√© odvozen√≠:</h5>
                            <div style="background: #f8f9fa; padding: 1rem; border-radius: 6px; font-size: 0.9rem;">
                                <strong>N√°kladov√° funkce:</strong><br>
                                \(C(x) = k_1 \cdot x + \frac{k_2}{x + x_0}\)<br><br>
                                <strong>Prvn√≠ derivace:</strong><br>
                                \(C'(x) = k_1 - \frac{k_2}{(x + x_0)^2}\)<br><br>
                                <strong>Druh√° derivace:</strong><br>
                                \(C''(x) = \frac{2k_2}{(x + x_0)^3}\)<br><br>
                                <strong>Newton-Raphson≈Øv vzorec:</strong><br>
                                \(x_{n+1} = x_n - \frac{C'(x_n)}{C''(x_n)}\)
                            </div>
                        </div>
                        <div>
                            <h5>Iterace pro n√°≈° p≈ô√≠klad:</h5>
                            <div id="newton-optimization-result" style="font-family: monospace; font-size: 0.8rem; background: #f8f9fa; padding: 0.8rem; border-radius: 6px;">
                                <button onclick="runNewtonOptimization()" style="padding: 0.5rem; background: #28a745; color: white; border: none; border-radius: 4px; margin-bottom: 0.5rem;">
                                    Spus≈• Newton-Raphsonovu metodu
                                </button>
                                <div id="newton-opt-iterations"></div>
                            </div>
                        </div>
                    </div>

                    <h4>Srovn√°n√≠ metod</h4>
                    <table style="width: 100%; margin-top: 1rem;">
                        <tr>
                            <th>Aspekt</th>
                            <th>Metoda zlat√©ho ≈ôezu</th>
                            <th>Newton-Raphson</th>
                        </tr>
                        <tr>
                            <td><strong>Rychlost konvergence</strong></td>
                            <td>Line√°rn√≠ (œÜ ‚âà 1.618)</td>
                            <td>Kvadratick√°</td>
                        </tr>
                        <tr>
                            <td><strong>Po≈æadavky</strong></td>
                            <td>Pouze funkƒçn√≠ hodnoty</td>
                            <td>Prvn√≠ a druh√° derivace</td>
                        </tr>
                        <tr>
                            <td><strong>Spolehlivost</strong></td>
                            <td>Velmi spolehliv√°</td>
                            <td>M≈Ø≈æe divergovat p≈ôi ≈°patn√©m odhadu</td>
                        </tr>
                        <tr>
                            <td><strong>Implementace</strong></td>
                            <td>Jednoduch√°</td>
                            <td>St≈ôedn√≠ slo≈æitost</td>
                        </tr>
                    </table>
                </div>
            </div>

            <div class="example">
                <h3>Interaktivn√≠ kalkul√°tor optimalizace</h3>
                <div style="background: #f8f9fa; border-radius: 12px; padding: 1.5rem; margin: 1rem 0; border: 2px solid #28a745;">
                    <h4>Optimalizace tlou≈°≈•ky izolace</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
                        <div>
                            <label>Cena izolace k‚ÇÅ [Kƒç/m]:</label>
                            <input type="number" id="k1" value="1500" step="100" style="width: 100%; padding: 0.5rem; margin: 0.3rem 0;">

                            <label>N√°klady na ztr√°ty k‚ÇÇ [Kƒç¬∑m]:</label>
                            <input type="number" id="k2" value="150" step="10" style="width: 100%; padding: 0.5rem; margin: 0.3rem 0;">
                        </div>
                        <div>
                            <label>P≈Øvodn√≠ tlou≈°≈•ka x‚ÇÄ [m]:</label>
                            <input type="number" id="x0" value="0.10" step="0.01" style="width: 100%; padding: 0.5rem; margin: 0.3rem 0;">

                            <button onclick="optimizeInsulation()" style="width: 100%; padding: 0.8rem; background: #28a745; color: white; border: none; border-radius: 6px; font-size: 1rem; margin-top: 1rem;">
                                Vypoƒç√≠tej optimum
                            </button>
                        </div>
                    </div>
                    <div id="optimization-result" style="background: white; padding: 1rem; border-radius: 8px; margin-top: 1rem; border-left: 4px solid #28a745;"></div>
                </div>
            </div>
        </section>

        <!-- Comparison Section -->
        <section class="unit-section">
            <h2>7. Srovn√°n√≠ metod</h2>

            <h3>Rychlost konvergence</h3>
            <table>
                <tr><th>Metoda</th><th>≈ò√°d konvergence (p)</th><th>Rychlost</th><th>Po≈æadavky</th></tr>
                <tr><td><strong>Newton-Raphson</strong></td><td>p = 2 (kvadratick√°)</td><td>Nejrychlej≈°√≠</td><td>Derivace, dobr√Ω odhad</td></tr>
                <tr><td><strong>Metoda seƒçen</strong></td><td>p ‚âà 1.618 (superline√°rn√≠)</td><td>Velmi rychl√°</td><td>Dva poƒç√°teƒçn√≠ body</td></tr>
                <tr><td><strong>Regula falsi</strong></td><td>p ‚âà 1 a≈æ 2</td><td>Rychl√°</td><td>Interval se zmƒõnou znam√©nka</td></tr>
                <tr><td><strong>Bisekce</strong></td><td>p = 1 (line√°rn√≠)</td><td>Pomal√°, ale jist√°</td><td>Interval se zmƒõnou znam√©nka</td></tr>
                <tr><td><strong>Prost√° iterace</strong></td><td>p = 1 (line√°rn√≠)</td><td>Z√°vis√≠ na g(x)</td><td>Vhodn√° transformace</td></tr>
            </table>

            <h3>Kdy pou≈æ√≠t kterou metodu?</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                <div>
                    <h4>Pro maxim√°ln√≠ rychlost:</h4>
                    <ul>
                        <li><strong>Newton-Raphson:</strong> Kdy≈æ zn√°me derivaci a m√°me dobr√Ω poƒç√°teƒçn√≠ odhad</li>
                        <li><strong>Metoda seƒçen:</strong> Kdy≈æ nezn√°me derivaci, ale chceme rychlost</li>
                    </ul>

                    <h4>Pro spolehlivost:</h4>
                    <ul>
                        <li><strong>Bisekce:</strong> Kdy≈æ pot≈ôebujeme jistotu konvergence</li>
                        <li><strong>Regula falsi:</strong> Kompromis mezi rychlost√≠ a spolehlivost√≠</li>
                    </ul>
                </div>
                <div>
                    <h4>Pro jednoduchost:</h4>
                    <ul>
                        <li><strong>Prost√° iterace:</strong> Pro jednoduch√© probl√©my nebo kdy≈æ je obt√≠≈æn√© implementovat jin√© metody</li>
                    </ul>

                    <h4>Praktick√© doporuƒçen√≠:</h4>
                    <ol>
                        <li>Zaƒçnƒõte bislekc√≠ pro nalezen√≠ p≈ôibli≈æn√©ho ≈ôe≈°en√≠</li>
                        <li>P≈ôepnƒõte na Newton-Raphson pro rychl√© zp≈ôesnƒõn√≠</li>
                        <li>Jako z√°lo≈æn√≠ pl√°n pou≈æijte regula falsi</li>
                    </ol>
                </div>
            </div>

            <div class="example">
                <h3>Srovn√°n√≠ rychlosti konvergence</h3>
                <div style="background: white; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #58508d;">
                    <div id="convergence-comparison" style="height: 400px;"></div>
                </div>
            </div>
        </section>

    </main>

    <script>
        // Configure MathJax
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['$$', '$$']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };

        // Graph functions
        function createNewtonGraph() {
            const x = [];
            const y = [];
            for (let i = -1; i <= 4; i += 0.01) {
                x.push(i);
                y.push(i*i*i - 6*i*i + 9*i + 1);
            }

            // Newton iterations
            let xVal = 0.5;
            const iterations = [xVal];
            const tangentLines = [];

            for (let i = 0; i < 4; i++) {
                const fx = xVal*xVal*xVal - 6*xVal*xVal + 9*xVal + 1;
                const dfx = 3*xVal*xVal - 12*xVal + 9;

                const xTan = [];
                const yTan = [];
                for (let t = xVal - 1; t <= xVal + 1; t += 0.01) {
                    xTan.push(t);
                    yTan.push(fx + dfx * (t - xVal));
                }

                tangentLines.push({
                    x: xTan,
                    y: yTan,
                    mode: 'lines',
                    line: {color: 'blue', dash: 'dash', width: 2},
                    name: `Teƒçna ${i+1}`,
                    showlegend: i === 0
                });

                xVal = xVal - fx / dfx;
                iterations.push(xVal);
            }

            const traces = [
                {
                    x: x,
                    y: y,
                    mode: 'lines',
                    line: {color: '#bc5090', width: 3},
                    name: 'f(x) = x¬≥ - 6x¬≤ + 9x + 1'
                },
                {
                    x: x,
                    y: new Array(x.length).fill(0),
                    mode: 'lines',
                    line: {color: 'black', width: 1},
                    showlegend: false
                },
                {
                    x: iterations,
                    y: iterations.map(xi => xi*xi*xi - 6*xi*xi + 9*xi + 1),
                    mode: 'markers',
                    marker: {color: 'red', size: 8},
                    name: 'Iterace'
                },
                ...tangentLines
            ];

            const layout = {
                title: 'Newton-Raphson metoda',
                xaxis: {title: 'x', range: [-1, 4]},
                yaxis: {title: 'f(x)', range: [-5, 10]},
                showlegend: false,
                margin: {l: 40, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('newton-graph', traces, layout, {responsive: true});
        }

        function createBisectionGraph() {
            const x = [];
            const y = [];
            for (let i = 0.5; i <= 2.5; i += 0.01) {
                x.push(i);
                y.push(i*i*i - i - 1);
            }

            let a = 1.0, b = 2.0;
            const intervals = [];
            const midpoints = [];

            for (let i = 0; i < 5; i++) {
                const c = (a + b) / 2;
                const fc = c*c*c - c - 1;
                const fa = a*a*a - a - 1;

                midpoints.push({
                    x: [c],
                    y: [fc],
                    mode: 'markers',
                    marker: {color: 'blue', size: 8},
                    name: `St≈ôed ${i+1}`,
                    showlegend: false
                });

                if (fa * fc < 0) {
                    b = c;
                } else {
                    a = c;
                }
            }

            const traces = [
                {
                    x: x,
                    y: y,
                    mode: 'lines',
                    line: {color: '#ff6361', width: 3},
                    name: 'f(x) = x¬≥ - x - 1'
                },
                {
                    x: x,
                    y: new Array(x.length).fill(0),
                    mode: 'lines',
                    line: {color: 'black', width: 1},
                    showlegend: false
                },
                ...midpoints
            ];

            const layout = {
                title: 'Metoda bisekce',
                xaxis: {title: 'x', range: [0.8, 2.2]},
                yaxis: {title: 'f(x)', range: [-2, 3]},
                showlegend: false,
                margin: {l: 40, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('bisection-graph', traces, layout, {responsive: true});
        }

        function createSecantGraph() {
            const x = [];
            const y = [];
            for (let i = -2; i <= 4; i += 0.01) {
                x.push(i);
                y.push(i*i - i - 3);
            }

            let x0 = 3.0, x1 = 3.5;
            const iterations = [x0, x1];
            const secantLines = [];

            for (let i = 0; i < 4; i++) {
                const fx0 = x0*x0 - x0 - 3;
                const fx1 = x1*x1 - x1 - 3;

                const slope = (fx1 - fx0) / (x1 - x0);
                const xSec = [];
                const ySec = [];

                for (let t = x0 - 1; t <= x1 + 0.5; t += 0.01) {
                    xSec.push(t);
                    ySec.push(fx1 + slope * (t - x1));
                }

                secantLines.push({
                    x: xSec,
                    y: ySec,
                    mode: 'lines',
                    line: {color: 'green', dash: 'dash', width: 2},
                    name: `Seƒçna ${i+1}`,
                    showlegend: i === 0
                });

                const xNew = x1 - fx1 * (x1 - x0) / (fx1 - fx0);
                iterations.push(xNew);
                x0 = x1;
                x1 = xNew;
            }

            const traces = [
                {
                    x: x,
                    y: y,
                    mode: 'lines',
                    line: {color: '#ffa600', width: 3},
                    name: 'f(x) = x¬≤ - x - 3'
                },
                {
                    x: x,
                    y: new Array(x.length).fill(0),
                    mode: 'lines',
                    line: {color: 'black', width: 1},
                    showlegend: false
                },
                {
                    x: iterations,
                    y: iterations.map(xi => xi*xi - xi - 3),
                    mode: 'markers',
                    marker: {color: 'red', size: 8},
                    name: 'Iterace'
                },
                ...secantLines
            ];

            const layout = {
                title: 'Metoda seƒçen',
                xaxis: {title: 'x', range: [-2, 4]},
                yaxis: {title: 'f(x)', range: [-4, 10]},
                showlegend: false,
                margin: {l: 40, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('secant-graph', traces, layout, {responsive: true});
        }

        function createFixedPointGraph() {
            const x = [];
            const y = [];
            const yLine = [];
            for (let i = 0; i <= 2; i += 0.01) {
                x.push(i);
                y.push(Math.cos(i));
                yLine.push(i);
            }

            let xVal = 0.5;
            const iterationsX = [xVal];
            const iterationsY = [0];
            const cobwebLines = [];

            for (let i = 0; i < 6; i++) {
                const gx = Math.cos(xVal);

                cobwebLines.push({
                    x: [xVal, xVal],
                    y: [i === 0 ? 0 : xVal, gx],
                    mode: 'lines',
                    line: {color: 'purple', dash: 'dot'},
                    showlegend: false
                });

                cobwebLines.push({
                    x: [xVal, gx],
                    y: [gx, gx],
                    mode: 'lines',
                    line: {color: 'purple', dash: 'dot'},
                    showlegend: false
                });

                iterationsX.push(xVal);
                iterationsY.push(gx);
                xVal = gx;
                iterationsX.push(xVal);
                iterationsY.push(xVal);
            }

            const traces = [
                {
                    x: x,
                    y: y,
                    mode: 'lines',
                    line: {color: '#58508d', width: 3},
                    name: 'y = cos(x)'
                },
                {
                    x: x,
                    y: yLine,
                    mode: 'lines',
                    line: {color: 'gray', dash: 'dash'},
                    name: 'y = x'
                },
                {
                    x: iterationsX,
                    y: iterationsY,
                    mode: 'markers+lines',
                    marker: {color: 'red', size: 6},
                    line: {color: 'red', width: 2},
                    name: 'Iterace'
                },
                ...cobwebLines
            ];

            const layout = {
                title: 'Prost√° iterace - pavuƒçinov√Ω diagram',
                xaxis: {title: 'x', range: [0, 1.5]},
                yaxis: {title: 'y', range: [0, 1.5]},
                showlegend: false,
                margin: {l: 40, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('fixed-point-graph', traces, layout, {responsive: true});
        }

        function createRegulaFalsiGraph() {
            const x = [];
            const y = [];
            for (let i = 0.5; i <= 2.5; i += 0.01) {
                x.push(i);
                y.push(i*i*i - i - 1);
            }

            let a = 1.0, b = 2.0;
            const iterations = [];
            const interpolationLines = [];

            for (let i = 0; i < 5; i++) {
                const fa = a*a*a - a - 1;
                const fb = b*b*b - b - 1;
                const c = (a * fb - b * fa) / (fb - fa);

                interpolationLines.push({
                    x: [a, b],
                    y: [fa, fb],
                    mode: 'lines',
                    line: {color: 'purple', dash: 'dash'},
                    name: `Interpolace ${i+1}`,
                    showlegend: i === 0
                });

                iterations.push(c);

                const fc = c*c*c - c - 1;
                if (fa * fc < 0) {
                    b = c;
                } else {
                    a = c;
                }
            }

            const traces = [
                {
                    x: x,
                    y: y,
                    mode: 'lines',
                    line: {color: '#003f5c', width: 3},
                    name: 'f(x) = x¬≥ - x - 1'
                },
                {
                    x: x,
                    y: new Array(x.length).fill(0),
                    mode: 'lines',
                    line: {color: 'black', width: 1},
                    showlegend: false
                },
                {
                    x: iterations,
                    y: iterations.map(xi => xi*xi*xi - xi - 1),
                    mode: 'markers',
                    marker: {color: 'red', size: 8},
                    name: 'Iterace'
                },
                ...interpolationLines
            ];

            const layout = {
                title: 'Regula falsi',
                xaxis: {title: 'x', range: [0.5, 2.5]},
                yaxis: {title: 'f(x)', range: [-2, 3]},
                showlegend: false,
                margin: {l: 40, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('regula-falsi-graph', traces, layout, {responsive: true});
        }

        function createConvergenceComparison() {
            const iterations = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            const newton = [1, 0.1, 0.001, 0.000001, 0.000000001, 0, 0, 0, 0, 0, 0];
            const secant = [1, 0.5, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0, 0, 0, 0];
            const bisection = [1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 0.0009765625];
            const regulaFalsi = [1, 0.3, 0.08, 0.02, 0.005, 0.001, 0.0002, 0.00004, 0.000008, 0.000002, 0.0000005];

            const traces = [
                {
                    x: iterations,
                    y: newton,
                    mode: 'lines+markers',
                    name: 'Newton-Raphson',
                    line: {color: '#bc5090', width: 3}
                },
                {
                    x: iterations,
                    y: secant,
                    mode: 'lines+markers',
                    name: 'Metoda seƒçen',
                    line: {color: '#ff6361', width: 3}
                },
                {
                    x: iterations,
                    y: regulaFalsi,
                    mode: 'lines+markers',
                    name: 'Regula falsi',
                    line: {color: '#ffa600', width: 3}
                },
                {
                    x: iterations,
                    y: bisection,
                    mode: 'lines+markers',
                    name: 'Bisekce',
                    line: {color: '#58508d', width: 3}
                }
            ];

            const layout = {
                title: 'Srovn√°n√≠ rychlosti konvergence',
                xaxis: {title: 'Poƒçet iterac√≠'},
                yaxis: {title: 'Absolutn√≠ chyba', type: 'log', range: [-10, 0]},
                showlegend: true,
                margin: {l: 60, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('convergence-comparison', traces, layout, {responsive: true});
        }

        function createInsulationOptimizationGraph() {
            // Realistic parameters for building insulation
            const k1 = 1500;  // Kƒç/m (realistic cost of insulation material)
            const k2 = 150;   // Kƒç¬∑m (realistic annual energy loss costs)
            const x0 = 0.10;  // m (realistic existing insulation thickness)

            // Generate thickness values - extended range to show minimum
            const x = [];
            const cost = [];
            const insulationCost = [];
            const energyCost = [];

            for (let thickness = 0.001; thickness <= 0.40; thickness += 0.001) {
                const totalCost = k1 * thickness + k2 / (thickness + x0);
                const insul = k1 * thickness;
                const energy = k2 / (thickness + x0);

                x.push(thickness);
                cost.push(totalCost);
                insulationCost.push(insul);
                energyCost.push(energy);
            }

            // Calculate optimal thickness
            const xOpt = Math.sqrt(k2 / k1) - x0;
            const costOpt = k1 * xOpt + k2 / (xOpt + x0);

            const traces = [
                {
                    x: x,
                    y: cost,
                    mode: 'lines',
                    name: 'Celkov√© n√°klady',
                    line: {color: '#bc5090', width: 4}
                },
                {
                    x: x,
                    y: insulationCost,
                    mode: 'lines',
                    name: 'N√°klady na izolaci',
                    line: {color: '#ff6361', width: 2, dash: 'dash'}
                },
                {
                    x: x,
                    y: energyCost,
                    mode: 'lines',
                    name: 'N√°klady na ztr√°ty',
                    line: {color: '#58508d', width: 2, dash: 'dot'}
                },
                {
                    x: [xOpt],
                    y: [costOpt],
                    mode: 'markers',
                    name: `Optimum (${xOpt.toFixed(3)} m)`,
                    marker: {color: '#28a745', size: 12, symbol: 'star'}
                }
            ];

            const layout = {
                title: 'Optimalizace tlou≈°≈•ky izolace',
                xaxis: {title: 'Tlou≈°≈•ka dodateƒçn√© izolace [m]'},
                yaxis: {title: 'N√°klady [Kƒç]'},
                showlegend: true,
                margin: {l: 60, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('insulation-optimization', traces, layout, {responsive: true});
        }

        function optimizeInsulation() {
            const k1 = parseFloat(document.getElementById('k1').value);
            const k2 = parseFloat(document.getElementById('k2').value);
            const x0 = parseFloat(document.getElementById('x0').value);

            // Calculate optimal thickness
            const xOpt = Math.sqrt(k2 / k1) - x0;
            const costOpt = k1 * xOpt + k2 / (xOpt + x0);

            // Calculate costs at zero additional insulation
            const costZero = k2 / x0;
            const savings = costZero - costOpt;
            const savingsPercent = ((costZero - costOpt) / costZero * 100);

            // Update result display
            document.getElementById('optimization-result').innerHTML = `
                <h5>V√Ωsledky optimalizace:</h5>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div>
                        <strong>Optim√°ln√≠ tlou≈°≈•ka:</strong> ${xOpt.toFixed(3)} m<br>
                        <strong>Celkov√° tlou≈°≈•ka:</strong> ${(xOpt + x0).toFixed(3)} m<br>
                        <strong>Minim√°ln√≠ n√°klady:</strong> ${costOpt.toFixed(0)} Kƒç
                    </div>
                    <div>
                        <strong>√öspora oproti x=0:</strong> ${savings.toFixed(0)} Kƒç<br>
                        <strong>Relativn√≠ √∫spora:</strong> ${savingsPercent.toFixed(1)}%<br>
                        <strong>Pomƒõr k‚ÇÇ/k‚ÇÅ:</strong> ${(k2/k1).toFixed(1)}
                    </div>
                </div>
                <div style="background: #d4edda; padding: 0.8rem; border-radius: 6px; margin-top: 1rem;">
                    <strong>Z√°vƒõr:</strong> Optim√°ln√≠ tlou≈°≈•ka je √∫mƒõrn√° druh√© odmocninƒõ z pomƒõru energetick√Ωch a materi√°lov√Ωch n√°klad≈Ø.
                </div>
            `;

            // Update graph with new parameters
            updateInsulationGraph(k1, k2, x0);
        }

        function updateInsulationGraph(k1, k2, x0) {
            const x = [];
            const cost = [];
            const insulationCost = [];
            const energyCost = [];

            for (let thickness = 0.001; thickness <= 0.5; thickness += 0.001) {
                const totalCost = k1 * thickness + k2 / (thickness + x0);
                const insul = k1 * thickness;
                const energy = k2 / (thickness + x0);

                x.push(thickness);
                cost.push(totalCost);
                insulationCost.push(insul);
                energyCost.push(energy);
            }

            const xOpt = Math.sqrt(k2 / k1) - x0;
            const costOpt = k1 * xOpt + k2 / (xOpt + x0);

            const traces = [
                {
                    x: x,
                    y: cost,
                    mode: 'lines',
                    name: 'Celkov√© n√°klady',
                    line: {color: '#bc5090', width: 4}
                },
                {
                    x: x,
                    y: insulationCost,
                    mode: 'lines',
                    name: 'N√°klady na izolaci',
                    line: {color: '#ff6361', width: 2, dash: 'dash'}
                },
                {
                    x: x,
                    y: energyCost,
                    mode: 'lines',
                    name: 'N√°klady na ztr√°ty',
                    line: {color: '#58508d', width: 2, dash: 'dot'}
                },
                {
                    x: [Math.max(0.001, xOpt)],
                    y: [costOpt],
                    mode: 'markers',
                    name: `Optimum (${Math.max(0.001, xOpt).toFixed(3)} m)`,
                    marker: {color: '#28a745', size: 12, symbol: 'star'}
                }
            ];

            const layout = {
                title: 'Optimalizace tlou≈°≈•ky izolace',
                xaxis: {title: 'Tlou≈°≈•ka dodateƒçn√© izolace [m]'},
                yaxis: {title: 'N√°klady [Kƒç]'},
                showlegend: true,
                margin: {l: 60, r: 40, t: 40, b: 40}
            };

            Plotly.newPlot('insulation-optimization', traces, layout, {responsive: true});
        }

        function runGoldenSection() {
            const k1 = 1500;
            const k2 = 150;
            const x0 = 0.10;

            // Golden ratio
            const phi = (1 + Math.sqrt(5)) / 2; // ‚âà 1.618
            const resphi = 2 - phi; // ‚âà 0.618

            // Cost function
            function cost(x) {
                return k1 * x + k2 / (x + x0);
            }

            // Initial interval
            let a = 0.001;
            let b = 0.4;
            let tolerance = 1e-6;
            let iterations = [];

            // Initial points
            let x1 = a + resphi * (b - a);
            let x2 = b - resphi * (b - a);
            let f1 = cost(x1);
            let f2 = cost(x2);

            iterations.push({
                iter: 0,
                a: a,
                b: b,
                x1: x1,
                x2: x2,
                f1: f1,
                f2: f2,
                interval: b - a
            });

            let iter = 1;
            while (Math.abs(b - a) > tolerance && iter < 20) {
                if (f1 < f2) {
                    b = x2;
                    x2 = x1;
                    f2 = f1;
                    x1 = a + resphi * (b - a);
                    f1 = cost(x1);
                } else {
                    a = x1;
                    x1 = x2;
                    f1 = f2;
                    x2 = b - resphi * (b - a);
                    f2 = cost(x2);
                }

                iterations.push({
                    iter: iter,
                    a: a,
                    b: b,
                    x1: x1,
                    x2: x2,
                    f1: f1,
                    f2: f2,
                    interval: b - a
                });

                iter++;
            }

            const optimum = (a + b) / 2;

            let output = `<strong>Metoda zlat√©ho ≈ôezu - Iterace:</strong><br>`;
            output += `iter |   a     |   b     | x1    | x2    | f1    | f2    | interval<br>`;
            output += `-----|---------|---------|-------|-------|-------|-------|----------<br>`;

            for (let i = 0; i < Math.min(8, iterations.length); i++) {
                const it = iterations[i];
                output += `${i.toString().padStart(2)} | ${it.a.toFixed(3)} | ${it.b.toFixed(3)} | ${it.x1.toFixed(3)} | ${it.x2.toFixed(3)} | ${it.f1.toFixed(1)} | ${it.f2.toFixed(1)} | ${it.interval.toFixed(6)}<br>`;
            }

            output += `<br><strong>V√Ωsledek:</strong> x* = ${optimum.toFixed(6)} m<br>`;
            output += `<strong>N√°klady:</strong> C* = ${cost(optimum).toFixed(1)} Kƒç<br>`;
            output += `<strong>Poƒçet iterac√≠:</strong> ${iter}<br>`;
            output += `<strong>P≈ôesnost:</strong> ¬±${((b-a)/2).toExponential(2)} m`;

            document.getElementById('golden-iterations').innerHTML = output;
        }

        function runNewtonOptimization() {
            const k1 = 1500;
            const k2 = 150;
            const x0 = 0.10;

            // First derivative: C'(x) = k1 - k2/(x + x0)^2
            function firstDerivative(x) {
                return k1 - k2 / Math.pow(x + x0, 2);
            }

            // Second derivative: C''(x) = 2*k2/(x + x0)^3
            function secondDerivative(x) {
                return 2 * k2 / Math.pow(x + x0, 3);
            }

            // Cost function
            function cost(x) {
                return k1 * x + k2 / (x + x0);
            }

            // Newton-Raphson iteration
            let x = 0.2; // Initial guess
            let tolerance = 1e-10;
            let iterations = [];

            iterations.push({
                iter: 0,
                x: x,
                f_prime: firstDerivative(x),
                f_double_prime: secondDerivative(x),
                cost: cost(x)
            });

            let iter = 1;
            while (iter < 10) {
                const fp = firstDerivative(x);
                const fpp = secondDerivative(x);

                if (Math.abs(fpp) < 1e-15) break; // Avoid division by zero

                const x_new = x - fp / fpp;

                iterations.push({
                    iter: iter,
                    x: x_new,
                    f_prime: firstDerivative(x_new),
                    f_double_prime: fpp,
                    cost: cost(x_new),
                    change: Math.abs(x_new - x)
                });

                if (Math.abs(x_new - x) < tolerance) break;

                x = x_new;
                iter++;
            }

            let output = `<strong>Newton-Raphsonova metoda - Iterace:</strong><br>`;
            output += `iter |   x     | C'(x)  | C''(x) | C(x)  | zmƒõna<br>`;
            output += `-----|---------|--------|--------|-------|--------<br>`;

            for (let i = 0; i < iterations.length; i++) {
                const it = iterations[i];
                const change = i > 0 ? it.change.toExponential(2) : "-";
                output += `${i.toString().padStart(2)} | ${it.x.toFixed(5)} | ${it.f_prime.toFixed(2)} | ${it.f_double_prime.toFixed(1)} | ${it.cost.toFixed(1)} | ${change}<br>`;
            }

            const finalX = iterations[iterations.length - 1].x;
            output += `<br><strong>V√Ωsledek:</strong> x* = ${finalX.toFixed(6)} m<br>`;
            output += `<strong>N√°klady:</strong> C* = ${cost(finalX).toFixed(1)} Kƒç<br>`;
            output += `<strong>Poƒçet iterac√≠:</strong> ${iter}<br>`;
            output += `<strong>Konvergence:</strong> Kvadratick√° (velmi rychl√°)<br>`;

            // Compare with analytical solution
            const analytical = Math.sqrt(k2 / k1) - x0;
            output += `<strong>Analytick√© ≈ôe≈°en√≠:</strong> ${analytical.toFixed(6)} m<br>`;
            output += `<strong>Rozd√≠l:</strong> ${Math.abs(finalX - analytical).toExponential(2)} m`;

            document.getElementById('newton-opt-iterations').innerHTML = output;
        }

        // Initialize graphs when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                createNewtonGraph();
                createBisectionGraph();
                createSecantGraph();
                createFixedPointGraph();
                createRegulaFalsiGraph();
                createConvergenceComparison();
                createInsulationOptimizationGraph();
            }, 100);
        });
    </script>
</body>
</html>